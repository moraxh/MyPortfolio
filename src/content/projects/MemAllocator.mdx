---
name: Memory Allocator
description: A memory allocator written from scratch in C.
tech: 
  - c
isProfessional: false
thumbnail: MemAllocator/thumbnail.png
githubName: MemAllocator
---
**MemAllocator** is a simple memory allocator implemented in **C**. It uses `sbrk()` to request memory, simulating a basic heap management system. This allocator allows **dynamic allocation and deallocation** of memory blocks.  

## ğŸ› ï¸ **Implementation Details**  

### ğŸ“Œ **The Program Break (`brk`)**  

The **program break** defines the **end of the process's data segment**. Increasing the program break allocates memory, while decreasing it deallocates memory. However, this method has some limitations:  

- âœ… **Allocating memory** is straightforwardâ€”just increment the `brk` pointer.  
- âŒ **Deallocating memory** is problematic since only the **most recently allocated block** (last allocated) can be freed.  

### ğŸ“Š **Memory Layout**  

#### **Initial Memory State**  
```plaintext
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚               â”‚
    â”‚    Block A    â”‚   0x0000
    â”‚               â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚               â”‚
    â”‚    Block B    â”‚   0x0010
    â”‚               â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚               â”‚
    â”‚      BRK      â”‚   0x0020
    â”‚               â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### **Allocating 16 Bytes** ğŸ’¾  
```plaintext
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚               â”‚
    â”‚    Block A    â”‚   0x0000
    â”‚               â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚               â”‚
    â”‚    Block B    â”‚   0x0010
    â”‚               â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚               â”‚
    â”‚    Block C    â”‚   0x0020
    â”‚               â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚               â”‚
    â”‚      BRK      â”‚   0x0030
    â”‚               â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### **Deallocating "Block C" (just decrease `brk`)** ğŸ”„  
```plaintext
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚               â”‚
    â”‚    Block A    â”‚   0x0000
    â”‚               â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚               â”‚
    â”‚    Block B    â”‚   0x0010
    â”‚               â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚               â”‚
    â”‚      BRK      â”‚   0x0020
    â”‚               â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### âš ï¸ **Problem with Deallocating Blocks in the Middle**  

If we want to deallocate **Block B** (not the last allocated block), the `brk` pointer **cannot** be decreased to reclaim that memory directly. Instead, only the **last allocated block (Block C)** can be freed.  

### âœ… **Solution: Free List**  

To address this limitation, a **Free List** is introduced to keep track of deallocated blocks for future reuse.  

## ğŸ·ï¸ **Memory Blocks with Headers**  

To manage memory effectively, each allocated block **stores its size in a Header** before the actual data.  

```plaintext
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  Header(size_t)  â”‚  Data  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

- The **Header** stores the **size of the block**.  
- The **data section** follows immediately after the Header.  
- Blocks are aligned to **16-byte boundaries** for performance and stability.  

## ğŸ—‚ï¸ **Free List Implementation**  

The **Free List** helps manage reusable memory blocks. It is a linked list where each block contains a **Header** and a pointer to the next available block.  

```plaintext
head(Header *)
        â”‚
        v
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  Header(size_t)  â”‚  FreeList(Header *)  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            v
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  Header(size_t)  â”‚  FreeList(Header *)  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            v
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  Header(size_t)  â”‚  FreeList(Header *)  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            v
          NULL
```  

### âš™ï¸ **How It Works**  

- Each block in the Free List contains:  
  - A **Header** (stores block size).  
  - A **pointer to the next free block**.  
- The `head` pointer points to the **first available block** in the Free List.  
- When a block is **freed**, it is **added back to the Free List** for future reuse.  
- Memory is aligned to **16-byte boundaries** for better performance and to prevent misalignment issues.  

## ğŸ“… **TODO â€“ Future Improvements**  

- [ ] **Implement memory allocation using `mmap`** for improved performance and flexibility.  
- [ ] **Add block splitting and merging** to optimize memory usage.  
- [ ] **Improve fragmentation handling** by implementing a best-fit or buddy allocation strategy.  